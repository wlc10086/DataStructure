# 1. 栈的定义

栈是一种特殊的线性表，插入和删除的运算只能在表的一端（表尾）进行，运算的一端称为**栈顶**，另一端称为**栈底**。


# 2. 栈的抽象数据类型

```c
ADT Stack{
数据对象：D={ai|ai∈ElemSet, i=1,2, …,n, n≥0}
数据关系：R1={<ai-1,ai>|ai-1,ai∈D, i=1,2, …,n }
       约定an端为栈顶,a1端为栈底。
基本操作：
   InitStack( &S )
     操作结果：构造一个空栈S。
   DestroyStack ( &S )
     初始条件：栈S已存在。
     操作结果：销毁栈S。
   ClearStack( &S )
     初始条件：栈S已存在。
     操作结果：将S清为空栈。
   StackEmpty( S )
     初始条件：栈S已存在。
     操作结果：若S为空栈,则返回TRUE,否则返回FALSE。
   StackLength( S )
     初始条件：栈S已存在。
     操作结果：返回S的数据元素个数,即栈的长度。
   GetTop( S, &e )
     初始条件：栈S已存在且非空。
     操作结果：用e返回S的栈顶元素。
   Push( &S, e )
     初始条件：栈S已存在。
     操作结果：插入元素e为新的栈顶元素。
   Pop( &S, &e )
     初始条件：栈S已存在且非空。
     操作结果：删除S的栈顶元素,并用e返回其值。
   StackTraverse( S, visit() )
     初始条件：栈S已存在且非空。
     操作结果：从栈底到栈顶依次对S的每个数据元素调用函数visit()。一旦visit()失败,则操作失败。
}END ADT
```



# 3. 栈的顺序存储结构

```c
// 描述一
#define MAXSIZE <存储的最大个数>
typedef struct{
  ElemType data[MAXSIZE];
  int top; //用于标记栈顶位置
}SqStack;

// 描述二
#define STACK_INIT_SIZE 20  // 初次初始大小
#define STACK_INCREMENT 10  // 增量

typedef struct
{ 
  ElemType *base;  // 指向栈底的指针变量
  ElemType *top;   // 指向栈顶的指针变量
  int StackSize;   // 栈当前最大容量(可增)
}SqStack;
```



# 4. 栈的链式存储结构

由于栈的插入和删除运算都在一端进行,因此在用链式存储实现的过程中,常常表现为在链表头进行操作,且在操作的过程中,也常常添加一表头结点简化操作（备注：但有时候没有空头结点反而容易操作）。 
起始就是链表的操作，入栈和出栈都在链表头操作。

```c
typedef struct LinkStackNode
{
	ElemType data;
	struct LinkStackNode* next;
}LinkStackNode, *ListStack;
```



# 5.栈的应用---逆波兰计算器

表达式的表示形式有中缀、前缀和后缀3中形式。  
而中缀表达式是操作符处于两个操作数之间的表达式,通常人们使用的就是这种形式。前缀和后缀表达式（也称为逆波兰表达式）分别是指操作数处于两个操作数之前和之后的表达式。  

正常表达式（中缀表达式）------>逆波兰表达式
- a+b ------>a b +
- a+(b-c)   --->a b c - +
- a+(b-c)*d --->a b c - d * +
- a+d*(b-c) --->a d b c - * +


如何转换思路(括号法)：  

假设存在中缀表达式：   
`中缀表达式a + b*c + (d * e + f) * g`

按照运算符的优先级对所有的运算单位加括号~  
式子变成：  
`（（a+（b*c））+（（（d*e+f）*g））`

2：转换前缀与后缀表达式
前缀：把运算符号移动到对应的括号前面  
则变成拉：+(+(a*(bc))*(+(*(de)+g))  
把括号去掉：++a*bc*+*de+g 前缀式子出现

后缀：把运算符号移动到对应的括号后面  
则变成拉：((a(bc)*)+(((de)*f)+g)*)+  
把括号去掉：abc*+de*f+g *+后缀式子出现

注意一点：  
在遇到像本式中a后面的+号和c后面的+的优先级问题，在正常计算时a后面的+会先使用所以他的优先级比c后面的+优先级高。所以能得到上面的二叉树。



# 6 递归

 递归就是直接或间接地由自己组成。解决递归问题的算法称为递归算法,用这种方式调用的函数称为递归函数。递归函数的执行过程实际上是一个函数嵌套调用过程。在递归调用中,就是根据递归条件直接或间接地调用算法本身,当满足终止条件时结束调用。

递归的一种效率比较低下的算法,一般能用迭代就用迭代（循环）代替,但是在解决某些问题时能让问题解决思路更简单。

**注意：必须要有一个明确结束递归的条件**。

## 6.1 斐波那契兔子问题
F(n)=F(n-1)+F(n-2)   (n>2)  
F(1)=1，F(2)=1  
```c
#define MAXNUM 40
 
int num[MAXNUM];
num[0] = 1,num[1] = 1;
for(int i=2;i<MAXNUM;i++)
num[i] = num[i-1] + num[i-2] ;

int F2(int n)
{
   if(n<=2)
      return  n==0?0:1; 
   return ( F2(n-1) + F2(n-2) );
}
```



## 6.2 汉诺塔

**汉诺塔**（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子,在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定,在小圆盘上不能放大圆盘,在三根柱子之间一次只能移动一个圆盘。

不管这个传说的可信度有多大,如果考虑一下把64片金片,由一根针上移到另一根针上,并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有n片,移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7,且f(k+1）=2*f(k)+1。此后不难证明**f(n)=2^n-1**。

使用递归解决汉诺塔能让思路异常清晰,具体代码如下：

```c

// 将输入任意长的字符串逆序输出
void print()
{
    char a;
    scanf("%c",&a);
    if( a!='#' )  print();
    if(a=='#')   printf("%c",a);
}

//把n个盘利用y,从x移动到z
void move(int n,char x,char y,char z)
{
  if(1==n)
    printf("%c-->%c\n",x,z);
  else{
    move(n-1,x,z,y);
    printf("%c-->%c\n",x,z);
    move(n-1,y,x,z);
  }
}
```

## 6.3 八皇后问题



# 7 分治思想

分治思想很常见,但问题规模比较大且不易求解的时候,可以将问题分成几个小的规模,逐一解决。分治思想和递归有一定关系,因为采用分治思想处理问题,其各个小模块通常具有与大问题相同的结构,这种特性也使递归技术有了用武之地。 

例如：折半查找法
