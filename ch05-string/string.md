# 1 定义

**串（String）**是由零个或多个字符组成的有限序列，又名为字符串。  
一般记为 s = “a1 a2 a3 .....an”（n>=0）  
其中s是串的名，串中字符的数目n称为串的长度，零个字符的串称为空串。

# 2 串的抽象数据类型
```
ADT String{
Data
串中的元素仅由一个字符组成,相邻元素具有前驱和后继关系
Operation
  StrAssign (&T, chars)
    初始条件：chars是字符串常量。
    操作结果：生成一个其值等于chars的串T。
  StrCopy (&T, S)
    初始条件：串S存在。
    操作结果：由串S复制得串T。
  StrEmpty(S)
    初始条件：串S存在。
    操作结果：若S为空串,则返回TRUE,否则返回FALSE。
  StrCompare(S, T)
    初始条件：串S和T存在。
    操作结果：若S>T,则返回值>0；若S=T,则返回值＝0；若S < T,则返回值 < 0。
  StrLength(S)
    初始条件：串S存在。
    操作结果：返回S的元素个数,称为串的长度。
  ClearString (&S)
    初始条件：串S存在。
    操作结果：将S清为空串。
  Concat (&T, S1, S2)
    初始条件：串S1和S2存在。
    操作结果：用T返回由S1和S2联接而成的新串。
  SubString(&Sub, S, pos, len)
    初始条件：串S存在,1≤pos≤StrLength(S)且0≤len≤StrLength(S)-pos+1
    操作结果：用Sub返回串S的第pos个字符长度为len的子串。
  Index(S, T, pos)
    初始条件：串S和T存在,T是非空串,1≤pos≤StrLength(S)。
    操作结果：若主串S中存在和串T值相同的子串,则返回它在主串S中第pos个字符之后第一次出现的位置;否则函数值为0。
  Replace (&S, T, V)
    初始条件：串S, T和V存在,T是非空串。
    操作结果：用V替换主串S中出现的所有与T相等的不重叠的子串。
  StrInsert (&S, pos, T)
    初始条件：串S和T存在, 1≤pos≤StrLength(S)+1。
    操作结果：在串S的第pos个字符之前插入串T。
  StrDelete (&S, pos, len)
    初始条件：串S存在, 1≤pos≤StrLength(S)－len+1。
    操作结果：从串S中删除第pos个字符起长度为len的子串。
  DestroyString (&S)
    初始条件：串S存在。
操作结果：串S被销毁。
}ADT String.
```

以下5个操作称为最小操作子集：

串赋值 StrAssign
串比较 StrCompare
求串长 StrLength
串联接 Concat
求子串 SubString

# 3 串的表示和实现

字符串的存储和线性表相同,同样存在顺序存储结构和链式存储结构。
```c
// 1.定长顺序存储
#define MAXSTRLEN 255
// 0号单元存放串的长度
typedef unsigned char SString[MAXSTRLEN+1]

// 堆分配存储表示
typedef struct{
	char *ch;	// 空串ch为NULL，否则按串长分配存储区
	int length;
}HString;

// 串的块链存储表示
#define CHUNKSIZE 80  // 块大小
typedef struct Chunk{
	char ch[CHUNKSIZE];
	struct Chunk *next;
}Chunk;

typedef struct{
	Chunk *head, *tail;
	int curlen;
}LString;
```


# 3 串的模式匹配

判断串t是否是串s的子串，如果是s的字串，则给出其在串s中的定位，这就是串的定位运算。我们把串s称为主串，串t称为子串，把串的定位运算称为**模式匹配**。这里讨论两种串的匹配算法（都采用顺序存储结构）

## 3.1 BF（Brute-Force）算法
&ensp;&ensp; BF算法属于朴素的匹配算法（蛮力法，他的思想是：有两个字符串S和T，长度为N和M。首先S[1]和T[1]比较，若相等，则再比较S[2]和T[2]，一直到T[M]为止；若S[1]和T[1]不等,则向右移动一个字符的位置，再依次进行比较。  
> 该算法最坏情况要进行M*(N-M+1)次比较,时间复杂度为O(M*N)。  


## 3.2 KMP算法
算法思想
每当一趟匹配过程中出现字符比较不等时，不需要回溯i指针，而是利用已经的带的“部分匹配”的结果将模式向右滑动尽可能远的一段距离后，继续进行比较。
即尽量利用已经部分匹配的结果信息，尽量让i不要回溯，加快模式串的滑动速度。

需要讨论两个问题：
①如何由当前部分匹配结果确定模式向右滑动的新比较起点k？
② 模式应该向右滑多远才是高效率的?

**现在讨论一般情况:**
假设 主串：s: ‘s(1) s(2) s(3) ……s(n)’ ;  模式串 ：p: ‘p(1) p(2) p(3)…..p(m)’
现在我们假设 主串第i个字符与模式串的第j(j<=m)个字符‘失配’后，主串第i个字符与模式串的第k(k<j)个字符继续比较。
此时，s(i)≠p(j)：

由此，我们得到关系式：即得到到1 到 **j -1** 的**"部分匹配"**结果:
$$
‘P(1) P(2) P(3)…..P(j-1)’  =  ’ S(i-j+1)……S(i-1)’
$$




 从而推导出k 到 j- 1位的“部分匹配”：即P**的****j-1～j-k****＝S前i-1～i- (k -1))位**       
$$
‘P(j - k + 1) …..P(j-1)’  =** **’S(i-k+1)S(i-k+2)……S(i-1)’
$$

由于s(i)≠p(j)，接下来s(i)将与p(k)继续比较，则模式串中的前(k-1)个字符的子串必须满足下列关系式，并且不可能存在 k’>k 满足下列关系式：(k<j)

有关系式： 即(P的前k- 1 ~ 1位＝ S前i-1～i-(k-1) )位 ) ,：
.
$$
‘P(1) P(2) P(3)…..P(k-1)’ = ’S(i-k+1)S(i-k+2)……S(i-1)’
$$

现在我们把前面总结的关系综合一下,有：

![img]()

由上，我们得到关系：

**‘p(1) p(2) p(3)…..p(k-1)’  =**  **‘p(j - k + 1) …..p(j-1)’** 

   反之，若模式串中满足该等式的两个子串，则当匹配过程中，主串中的第i 个字符与模式中的第j个字符等时，仅需要将模式向右滑动至模式中的第k个字符和主串中的第i个字符对齐。此时，模式中头k-1个字符的子串‘p(1) p(2) p(3)…..p(k-1)’ 必定与主串中的第i 个字符之前长度为k-1 的子串 ’s(j-k+1)s(j-k+2)……s(j-1)’相等，由此，匹配仅需要从模式中的第 k 个字符与主串中的第 i 个字符比较起 继续进行。   若令 next[j] = k ,则next[j] 表明当模式中第j个字符与主串中相应字符“失配”时，在模式中需要重新和主串中该字符进行的比较的位置。由此可引出模式串的next函数：

根据模式串P的规律： **‘p(1) p(2) p(3)…..p(k-1)’  =  ‘p(j - k + 1) …..p(j-1)’** 

由当前失配位置j(已知) ，可以归纳计算新起点k的表达式。

![img]()

由此定义可推出下列模式串next函数值：

![img]()

模式匹配过程:

![img]()

**KMP算法的实现:**

第一步，先把模式T所有可能的失配点j所对应的next[j]计算出来；

第二步：执行定位函数Index_kmp（与BF算法模块非常相似）

1. **int** KMPindex(SString S, SString T, **int** pos) 
2. { 
3.   **if** (pos <1 || pos > S[0] ) 
4. ​    exit(ERROR); 
5.   **int** i = pos, j =1;  
6.   **while** (i<= S[0] && j <= T[0]) 
7.   { 
8. ​    **if** (S[i] == T[j]) 
9. ​    {  
10. ​      ++i; ++j; 
11. ​    } 
12. ​    **else** 
13. ​    { 
14. ​      j = next[j+1]; 
15. ​    } 
16.   }
17.  
18.   **if**(j > T[0]) **return** i - T[0]; 
19.   **return** ERROR; 
20. } 

完整实现代码：

1. // Test.cpp : Defines the entry point for the console application.  
2. //  
3. \#include "stdafx.h"  
4. \#include <stdio.h>  
5. \#include "stdlib.h" 
6. \#include <iostream> 
7. **using** **namespace** std; 
8.  
9. //宏定义   
10. \#define TRUE  1   
11. \#define FALSE  0   
12. \#define OK  1   
13. \#define ERROR  0  
14.  
15. \#define MAXSTRLEN 100 
16.  
17. **typedef** **char**  SString[MAXSTRLEN + 1]; 
18.  
19. **void** GetNext(SString T, **int** next[]); 
20. **int** KMPindex(SString S, SString T, **int** pos); 
21. /************************************************************************/ 
22. /* 
23.  返回子串T在主串S中第pos位置之后的位置，若不存在，返回0 
24. */ 
25. /************************************************************************/ 
26. **int** KMPindex(SString S, SString T, **int** pos) 
27. { 
28.   **if** (pos <1 || pos > S[0] ) exit(ERROR); 
29.   **int** i = pos, j =1; 
30.   **int** next[MAXSTRLEN]; 
31.   GetNext( T, next); 
32.   **while** (i<= S[0] && j <= T[0]) 
33.   { 
34. ​    **if** (S[i] == T[j]) { 
35. ​      ++i; ++j; 
36. ​    } **else** { 
37. ​      j = next[j]; 
38. ​    } 
39.   } 
40.   **if**(j > T[0]) **return** i - T[0]; 
41.   **return** ERROR; 
42. } 
43.  
44. /************************************************************************/ 
45. /*   求子串next[i]值的算法 
46. */ 
47. /************************************************************************/ 
48. **void** GetNext(SString T, **int** next[]) 
49. {  **int** j = 1, k = 0; 
50.   next[1] = 0; 
51.   **while**(j < T[0]){ 
52. ​    **if**(k == 0 || T[j]==T[k]) {   
53. ​      ++j; ++k;  next[j] = k;  
54. ​    } **else** { 
55. ​      k = next[k];  
56. ​    } 
57.   } 
58. } 
59.  
60. **void** main(){ 
61.   SString S = {13,'a','b','a','b','c','a','b','c','a','c','b','a','b'}; 
62.   SString T = {5,'a','b','c','a','c'}; 
63.   **int** pos; 
64.   pos = KMPindex( S, T, 1); 
65.   cout<<"Pos:"<<pos; 
66. } 

**2.2  求串的模式值next[n]**

k值仅取决于模式串本身而与相匹配的主串无关。

我们使用递推到方式求next函数：

1）由定义可知：

   next[1] = 0;

2)  设 next[j] = k ,这个表面在模式串中存在下列关系：

  **‘P(1)  ….. P(k-1)’  =**  **‘P(j - k + 1) ….. P(j-1)’** 

  其中k为满足1< k <j的某个值，并且不可能存在k` > 满足:

  **‘P(1)  ….. P(k`-1)’  =**  **‘P(j - k` + 1) ….. P(j-1)’** 

  此时next[j+1] = ?可能有两种情况：

  （1） 若Pk = Pj，则表明在模式串中：

 **‘P(1) ….. P(k)’  =  ‘P(j - k + 1) ….. P(j)’** 

​     并且不可能存在k` > 满足： **‘P(1) ….. P(k`)’  =  ‘P(j - k` + 1) ….. P(j)’** 

​     即next[j+1] = k + 1 推到=》：

​     next[j+1] = next[j] + 1;

   (2)  若Pk

![img]()

Pj 则表明在模式串中：

​     **‘P(1) ….. P(k)’**  

![img]()

  **‘P(j - k + 1) ….. P(j)’** 

   此时可把next函数值的问题看成是一个模式匹配的问题，整个模式串即是主串又是模式串，

   而当前匹配的过程中，已有：

   Pj-k+1 = P1， Pj-k+2 = P2，... Pj-1 = Pk-1.

   则当Pk

![img]()

Pj时应将模式向右滑动至以模式中的第next[k]个字符和主串中的第 j 个字符相比较。

   若next[k] = k`,且Pj= Pk`, 则说明在主串中的第j+1 个字符之前存在一个长度为k` (即next[k])的最长子串，和模式串

   从首字符其长度为看k`的子串箱等。即

​    **‘P(1) ….. P(k`)’  = ‘P(j - k` + 1) ….. P(j)’** 

   也就是说next[j+1] = k` +1 即

   next[j+1] = next[k] + 1

   同理，若Pj 

![img]()

Pk` ,则将模式继续向右滑动直至将模式串中的第next[k`]个字符和Pj对齐，

   ... ,一次类推，直至Pj和模式中某个字符匹配成功或者不存在k`(1< k` < j)满足，则:

   next[j+1] =1;

  

![img]()

1. /************************************************************************/ 
2. /*   求子串next[i]值的算法 
3. */ 
4. /************************************************************************/ 
5. **void** GetNext(SString T, **int** next[]) 
6. {  **int** j = 1, k = 0; 
7.   next[1] = 0; 
8.   **while**(j < T[0]){ 
9. ​    **if**(k == 0 || T[j]==T[k]) {   
10. ​      ++j; ++k;  next[j] = k;  
11. ​    } **else** { 
12. ​      k = next[k];  
13. ​    } 
14.   } 
15. } 

next 函数值究竟是什么含义，前面说过一些，这里总结。

设在字符串S中查找模式串T，若S[m]!=T[n],那么，取T[n]的模式函数值next[n],

\1.    next[n] = 0 表示S[m]和T[1]间接比较过了，不相等，下一次比较 S[m+1] 和T[1]

\2.    next[n] =1 表示比较过程中产生了不相等，下一次比较 S[m] 和T[1]。

\3.    next[n] = k >1 但k<n, 表示,S[m]的前k个字符与T中的开始k个字符已经间接比较相等了，下一次比较S[m]和T[k]相等吗？

\4.    其他值，不可能。

注意：

（1）k值仅取决于模式串本身而与相匹配的主串无关。

（2）k值为模式串从头向后及从j向前的两部分的最大相同子串的长度。

（3）这里的两部分子串可以有部分重叠的字符，但不可以全部重叠。

next[j]函数表征着模式P中最大相同前缀子串和后缀子串（真子串）的长度。

可见，模式中相似部分越多，则next[j]函数越大，它既表示模式T字符之间的相关度越高，也表示j位置以前与主串部分匹配的字符数越多。

即：next[j]越大，模式串向右滑动得越远，与主串进行比较的次数越少，时间复杂度就越低（时间效率）。

 