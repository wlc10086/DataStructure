# 1. 栈的定义

栈是一种特殊的线性表,插入和删除的运算只能在表的一端（表尾）进行,运算的一端称为栈顶,另一端称为栈底。


# 2. 栈的抽象数据类型

```c
ADT Stack{
数据对象：D={ai|ai∈ElemSet, i=1,2, …,n, n≥0}
数据关系：R1={<ai-1,ai>|ai-1,ai∈D, i=1,2, …,n }
       约定an端为栈顶,a1端为栈底。
基本操作：
   InitStack( &S )
     操作结果：构造一个空栈S。
   DestroyStack ( &S )
     初始条件：栈S已存在。
     操作结果：销毁栈S。
   ClearStack( &S )
     初始条件：栈S已存在。
     操作结果：将S清为空栈。
   StackEmpty( S )
     初始条件：栈S已存在。
     操作结果：若S为空栈,则返回TRUE,否则返回FALSE。
   StackLength( S )
     初始条件：栈S已存在。
     操作结果：返回S的数据元素个数,即栈的长度。
   GetTop( S, &e )
     初始条件：栈S已存在且非空。
     操作结果：用e返回S的栈顶元素。
   Push( &S, e )
     初始条件：栈S已存在。
     操作结果：插入元素e为新的栈顶元素。
   Pop( &S, &e )
     初始条件：栈S已存在且非空。
     操作结果：删除S的栈顶元素,并用e返回其值。
   StackTraverse( S, visit() )
     初始条件：栈S已存在且非空。
     操作结果：从栈底到栈顶依次对S的每个数据元素调用函数visit()。一旦visit()失败,则操作失败。
}END ADT
```

# 3. 栈的顺序存储结构

```c
// 描述一
#define MAXSIZE <存储的最大个数>
typedef struct{
  ElemType data[MAXSIZE];
  int top; //用于标记栈顶位置
}SqStack;
```

```c
// 描述二
#define STACK_INIT_SIZE 20  // 初次初始大小
#define STACK_INCREMENT 10  // 增量

typedef struct
{ 
  ElemType *base;  // 指向栈底的指针变量
  ElemType *top;   // 指向栈顶的指针变量
  int StackSize;   // 栈当前最大容量(可增)
}SqStack;
```

# 4. 栈的链式存储结构

由于栈的插入和删除运算都在一端进行,因此在用链式存储实现的过程中,常常表现为在链表头进行操作,且在操作的过程中,也常常添加一表头结点简化操作（备注：但有时候没有空头结点反而容易操作）。  
起始就是链表的操作，入栈和出栈都在链表头操作。

```c
typedef struct ListStackNode
{
	ElemType data;
	struct ListStackNode* next;
}ListStackNode, *ListStack;
```


# 5.栈的应用---逆波兰计算器

表达式的表示形式有中缀、前缀和后缀3中形式。  
而中缀表达式是操作符处于两个操作数之间的表达式,通常人们使用的就是这种形式。前缀和后缀表达式（也称为逆波兰表达式）分别是指操作数处于两个操作数之前和之后的表达式。  

正常表达式（中缀表达式）------>逆波兰表达式
- a+b ------>a b +
- a+(b-c)   --->a b c - +
- a+(b-c)*d --->a b c - d * +
- a+d*(b-c) --->a d b c - * +


如何转换思路(括号法)：  

假设存在中缀表达式：   
`中缀表达式a + b*c + (d * e + f) * g`

按照运算符的优先级对所有的运算单位加括号~  
式子变成：  
`（（a+（b*c））+（（（d*e+f）*g））`

2：转换前缀与后缀表达式
前缀：把运算符号移动到对应的括号前面  
则变成拉：+(+(a*(bc))*(+(*(de)+g))  
把括号去掉：++a*bc*+*de+g 前缀式子出现

后缀：把运算符号移动到对应的括号后面  
则变成拉：((a(bc)*)+(((de)*f)+g)*)+  
把括号去掉：abc*+de*f+g *+后缀式子出现

注意一点：  
在遇到像本式中a后面的+号和c后面的+的优先级问题，在正常计算时a后面的+会先使用所以他的优先级比c后面的+优先级高。所以能得到上面的二叉树。



 