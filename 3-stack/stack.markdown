# 1. 栈的定义

栈是一种特殊的线性表,插入和删除的运算只能在表的一端（表尾）进行,运算的一端称为栈顶,另一端称为栈底。


# 2. 栈的抽象数据类型

```c
ADT Stack{
数据对象：D={ai|ai∈ElemSet, i=1,2, …,n, n≥0}
数据关系：R1={<ai-1,ai>|ai-1,ai∈D, i=1,2, …,n }
       约定an端为栈顶,a1端为栈底。
基本操作：
   InitStack( &S )
     操作结果：构造一个空栈S。
   DestroyStack ( &S )
     初始条件：栈S已存在。
     操作结果：销毁栈S。
   ClearStack( &S )
     初始条件：栈S已存在。
     操作结果：将S清为空栈。
   StackEmpty( S )
     初始条件：栈S已存在。
     操作结果：若S为空栈,则返回TRUE,否则返回FALSE。
   StackLength( S )
     初始条件：栈S已存在。
     操作结果：返回S的数据元素个数,即栈的长度。
   GetTop( S, &e )
     初始条件：栈S已存在且非空。
     操作结果：用e返回S的栈顶元素。
   Push( &S, e )
     初始条件：栈S已存在。
     操作结果：插入元素e为新的栈顶元素。
   Pop( &S, &e )
     初始条件：栈S已存在且非空。
     操作结果：删除S的栈顶元素,并用e返回其值。
   StackTraverse( S, visit() )
     初始条件：栈S已存在且非空。
     操作结果：从栈底到栈顶依次对S的每个数据元素调用函数visit()。一旦visit()失败,则操作失败。
}END ADT
```

# 3. 栈的顺序存储结构

```c
// 描述一
#define MAXSIZE <存储的最大个数>
typedef struct{
  ElemType data[MAXSIZE];
  int top; //用于标记栈顶位置
}SqStack;
```

```c
// 描述二
#define STACK_INIT_SIZE 20  // 初次初始大小
#define STACK_INCREMENT 10  // 增量

typedef struct
{ 
  ElemType *base;  // 指向栈底的指针变量
  ElemType *top;   // 指向栈顶的指针变量
  int StackSize;   // 栈当前最大容量(可增)
}SqStack;
```

# 4. 栈的链式存储结构

由于栈的插入和删除运算都在一端进行,因此在用链式存储实现的过程中,常常表现为在链表头进行操作,且在操作的过程中,也常常添加一表头结点简化操作（备注：但有时候没有空头结点反而容易操作）。  
起始就是链表的操作，入栈和出栈都在链表头操作。

```c
typedef struct ListStackNode
{
	ElemType data;
	struct ListStackNode* next;
}ListStackNode, *ListStack;
```


# 5.栈的应用---逆波兰计算器

表达式的表示形式有中缀、前缀和后缀3中形式。而中缀表达式是操作符处于两个操作数之间的表达式,通常人们使用的就是这种形式。前缀和后缀表达式（也称为逆波兰表达式）分别是指操作数处于两个操作数之前和之后的表达式。  

正常表达式（中缀表达式）------>逆波兰表达式
- a+b ------>a b +
- a+(b-c)   --->a b c - +
- a+(b-c)*d --->a b c - d * +
- a+d*(b-c) --->a d b c - * +

如何转换思路：
1+（2-3）*4+10/5 ----> 1 2 3 - 4 * + 10 5 / + （这里结果=-1）

1. 首先遇到第一个输入是1,数字在后缀表达式中都是直接输出,接着是符号‘+’,入栈。此时：
> 输出：1  
栈内：+  

2. 第三个字符是’(’,依然是符号,入栈,接着是数字2,输出,然后是符号’-’,入栈。此时：
> 输出：1 2   
栈内：+ ( - 

3. 接着是数字3,输出,紧跟这是“）”,此时,我们需要去匹配栈里的“（”,然后再匹配前将栈顶数据依次出栈（这就好比括号里优先执行的道理）
输出：1 2 3  
栈内：+

4. 紧接着是符号“*”,直接入栈：
> 输出：1 2 3   
栈内：+ *

5. 遇到数字4,输出,之后是符号“+”,此时栈顶元素是符号“*”,按照先乘除后加减原理,此时栈顶的乘号优先级比即将入栈的加号要大,所以出栈。
> 输出：1 2 3 - 4 *   
栈内：+

6. 栈中原有+,理应跟即将入栈的加号“+”同级,但先来后到的原则,栈里的加号需要出栈玩玩。（同理如果栈里面还有其他操作符,也是出栈）,接着+入栈。
> 输出：1 2 3 - 4 * +   
栈内：+

6. 紧接着数字10,输出,最后是符号“/”,入栈
> 输出：1 2 3 - 4 * + 10  
栈内：+ /

7. 最后一个数字5,输出：
> 输出：1 2 3 - 4 * + 10 5   
栈内：+ /

8. 所有输入处理完毕,如果栈中仍然有数据,所以将栈中符号依次出栈。
> 输出：1 2 3 - 4 * + 10 5 / +  
栈内：

**中缀表达式转后缀表达式总结：**  
中缀表达式a + b*c + (d * e + f) * g , 其转换成后缀表达式则为a b c * + d e * f  + g * +。


**转换过程需要用到栈, 具体过程如下：**

* 如果遇到操作数,我们就直接将其输出。
* 如果遇到操作符,则我们将其放入到栈中,遇到左括号时我们也将其放入栈中。
* 如果遇到一个右括号,则将栈元素弹出,将弹出的操作符输出直到遇到左括号为止。注意，左括号只弹出并不输出。
* 如果遇到任何其他的操作符,如（“+”, “*”,“（”）等,从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止。弹出完这些元素后,才将遇到的操作符压入到栈中。有一点需要注意,只有在遇到" ) "的情况下我们才弹出" ( ",其他情况我们都不会弹出" ( "。也就是说这种操作," + "的优先级最低," ( "优先级最高。
* 如果我们读到了输入的末尾,则将栈中所有剩余元素依次弹出。
 